\section{Phân tích chi tiết các thành phần của dự án}

Phần này phân tích chi tiết các thành phần frontend và backend của dự án Việt Food. Em sẽ đi sâu vào các tính năng nổi bật, kỹ thuật triển khai, và những giải pháp được áp dụng để đảm bảo hiệu suất và trải nghiệm người dùng tốt.

\section{Frontend - Giao diện người dùng}

\subsection{Cấu trúc component hiện đại}

Frontend của Việt Food được xây dựng bằng React và TypeScript, áp dụng một cấu trúc có tính mô-đun cao và dễ bảo trì. Hệ thống component được tổ chức theo các lớp:

\begin{enumerate}
    \item \textbf{Chia nhỏ component}: Các thành phần UI được tách thành các component nhỏ để tăng khả năng tái sử dụng.
    \item \textbf{Cô lập logic}: Logic được tách biệt với giao diện thông qua các custom hooks.
\end{enumerate}


\subsection{Styling và Thiết kế}

Việt Food sử dụng Tailwind CSS kết hợp với các component từ Radix UI để tạo ra một hệ thống giao diện nhất quán và hiện đại:

\begin{itemize}
    \item \textbf{Utility-first CSS}: Sử dụng các lớp của Tailwind giúp phát triển nhanh và nhất quán.
    \item \textbf{Theme Configuration}: Hệ thống màu sắc, typography, và spacing được cấu hình trong tailwind.config.ts.
    \item \textbf{Component Libraries}: Sử dụng Radix UI làm nền tảng, tùy chỉnh với Tailwind CSS.
    \item \textbf{Responsive Design}: Ứng dụng được thiết kế đáp ứng trên các kích thước màn hình khác nhau.
\end{itemize}


\subsection{Quản lý dữ liệu và State Management}

Việt Food sử dụng một hỗn hợp các công cụ để quản lý dữ liệu và trạng thái ứng dụng:

\begin{itemize}
    \item \textbf{React Context API}: Quản lý trạng thái toàn cục của ứng dụng như xác thực người dùng (auth), giỏ hàng (cart).
    \item \textbf{Custom Hooks}: Tạo ra các hooks chuyên biệt như useAuth, useProfile để truy cập và cập nhật trạng thái.
    \item \textbf{Zod}: Validation dữ liệu chặt chẽ với TypeScript.
    \item \textbf{Local Storage}: Lưu trữ access token và refresh token trên client.
\end{itemize}

Hệ thống quản lý giỏ hàng sử dụng Context API với các tính năng chính:
\begin{itemize}
    \item Quản lý danh sách sản phẩm trong giỏ hàng
    \item Theo dõi trạng thái mở/đóng giỏ hàng
    \item Các thao tác thêm, xóa, cập nhật số lượng sản phẩm
    \item Tính toán tự động tổng tiền và số lượng sản phẩm
\end{itemize}

Custom hook \texttt{useCart} được sử dụng để truy cập ngữ cảnh giỏ hàng từ bất kỳ component nào trong ứng dụng một cách dễ dàng.

\subsection{Routing và Navigation}

Việt Food sử dụng thư viện wouter cho routing nhẹ nhàng và hiệu quả:

\begin{itemize}
    \item \textbf{Lazy Loading}: Các trang được tải lazy để giảm kích thước bundle ban đầu.
    \item \textbf{Route Protection}: Các route được bảo vệ dựa trên vai trò người dùng.
    \item \textbf{URL Params và Query Strings}: Xử lý các tham số đường dẫn và query string cho tìm kiếm và lọc.
\end{itemize}

Hệ thống routing được cấu hình với các tính năng chính:
\begin{itemize}
    \item Định nghĩa các route chính: Trang chủ, Danh sách món ăn, Chi tiết món, Giỏ hàng
    \item Sử dụng lazy loading để tải các component khi cần thiết
    \item Bảo vệ các route yêu cầu xác thực
    \item Xử lý các tham số động trong URL
\end{itemize}

\section{Backend - Kỹ thuật tối ưu hóa}

\subsection{Redis Caching}

Hệ thống sử dụng Redis làm hệ thống cache để tối ưu hóa thời gian truy vấn dữ liệu. Redis được cấu hình và khởi tạo trong file \texttt{config/redis.ts}. Cache dữ liệu món ăn là loại dữ liệu được truy cập thường xuyên nhưng ít thay đổi, nên việc cache là rất hiệu quả. Hệ thống sử dụng kỹ thuật "prime cache" khi khởi động server - tức là nạp trước dữ liệu phổ biến vào cache. Khi dữ liệu thay đổi, cache cần được cập nhật hoặc xóa để tránh dữ liệu không đồng bộ.
\subsection{Khái niệm và lợi ích}
Redis là hệ thống lưu trữ dữ liệu key-value trong bộ nhớ, có khả năng lưu trữ nhiều kiểu dữ liệu khác nhau. Trong Việt Food, Redis được sử dụng chủ yếu làm hệ thống cache để tối ưu hóa thời gian truy vấn dữ liệu:

\begin{itemize}
    \item \textbf{Tốc độ truy xuất nhanh}: Dữ liệu được lưu trong bộ nhớ, giảm độ trễ so với truy vấn database
    \item \textbf{Giảm tải cho database chính}: Các truy vấn phổ biến được cache, giảm số lượng truy cập vào MongoDB
    \item \textbf{Tăng khả năng phục vụ đồng thời}: Hệ thống có thể xử lý nhiều request hơn trong cùng một thời điểm
\end{itemize}

\subsection{Triển khai trong dự án}
Trong Việt Food, Redis được cấu hình và khởi tạo trong file \texttt{config/redis.ts}:

Cấu hình Redis được thiết lập thông qua thư viện \texttt{ioredis}, kết nối đến máy chủ Redis thông qua các biến môi trường. Hệ thống ghi log khi kết nối thành công hoặc gặp lỗi.

\subsection{Cache dữ liệu món ăn}
Dữ liệu món ăn là loại dữ liệu được truy cập thường xuyên nhưng ít thay đổi, nên việc cache là rất hiệu quả. Trong \texttt{DishService}, các phương thức tìm kiếm món ăn đều áp dụng caching:

Phương thức `findById` triển khai cơ chế cache-aside pattern. Khi nhận yêu cầu, hệ thống kiểm tra dữ liệu trong cache trước, nếu không có mới truy vấn database. Dữ liệu được lưu trong cache 24 giờ.

\subsection{Prime Cache khi khởi động}
Hệ thống áp dụng kỹ thuật "prime cache" khi khởi động server, nạp trước tất cả món ăn đang có sẵn vào Redis. Quá trình này giúp giảm thời gian phản hồi cho các truy vấn đầu tiên bằng cách đảm bảo dữ liệu thường dùng luôn sẵn sàng trong bộ nhớ đệm. Khi server khởi động, hệ thống thực hiện các bước sau:

1. Kết nối cơ sở dữ liệu chính
2. Thiết lập kết nối với Elasticsearch
3. Gọi phương thức `primeAllDishesCache()` để nạp trước dữ liệu món ăn vào Redis

\subsection{Invalidation cache}
Khi dữ liệu thay đổi, cache cần được cập nhật hoặc xóa để tránh dữ liệu không đồng bộ. Việt Food xử lý vấn đề này bằng cách xóa các key cache liên quan khi có thay đổi:

Khi dữ liệu món ăn thay đổi, hệ thống tự động xóa các key cache liên quan để đảm bảo tính nhất quán dữ liệu. Quá trình này sử dụng pipeline để tối ưu hiệu năng khi xóa nhiều key cùng lúc, đảm bảo dữ liệu hiển thị cho người dùng luôn được cập nhật mới nhất.

\section{Redis Stream}

\subsection{Khái niệm và lợi ích}
Redis Stream là một cấu trúc dữ liệu mới trong Redis, cho phép lưu trữ và quản lý các dòng sự kiện theo thời gian thực, tương tự như một message broker:

\begin{itemize}
    \item \textbf{Xử lý tin nhắn không đồng bộ}: Các thành phần khác nhau có thể giao tiếp mà không cần chờ đợi nhau
    \item \textbf{Mô hình publish-subscribe}: Phân tách giữa producer và consumer
    \item \textbf{Khả năng mở rộng}: Nhiều consumer có thể xử lý cùng một stream
    \item \textbf{Độ tin cậy}: Tin nhắn được lưu trữ lâu dài và có thể được xử lý lại nếu cần
\end{itemize}

\subsection{Triển khai trong dự án}
Trong Việt Food, Redis Stream được sử dụng chủ yếu để xử lý tin nhắn. Đầu tiên, stream key được định nghĩa trong file cấu hình Redis:

Hệ thống định nghĩa một hằng số \texttt{MESSAGE\_STREAM\_KEY} với giá trị \texttt{"message\_stream"} để xác định Redis Stream dùng cho việc xử lý tin nhắn.

MessageWorkerService xử lý tin nhắn từ stream:

Lớp \texttt{MessageWorkerService} đảm nhận việc xử lý tin nhắn từ Redis Stream với hai phương thức chính:

\begin{enumerate}
    \item \texttt{createConsumerGroup()}: Thiết lập nhóm người tiêu dùng (consumer group) cho Redis Stream nếu chưa tồn tại
    \item \texttt{processStreamMessages()}: Vòng lặp vô hạn đọc và xử lý tin nhắn từ stream, sử dụng cơ chế blocking read để tiết kiệm tài nguyên
\end{enumerate}

Quá trình xử lý bao gồm việc chuyển đổi dữ liệu từ định dạng stream sang đối tượng tin nhắn và lưu vào cơ sở dữ liệu thông qua `MessageService`.

Stream consumer được khởi động riêng biệt từ file \texttt{consumer.ts}:

Quá trình khởi động consumer bao gồm các bước:
1. Nhập module `MessageWorkerService` từ đường dẫn tương ứng
2. Tạo một hàm tự thực thi không đồng bộ (async IIFE)
3. Khởi tạo nhóm người tiêu dùng
4. Bắt đầu xử lý tin nhắn từ stream

Cách tiếp cận này đảm bảo consumer luôn sẵn sàng xử lý tin nhắn mới ngay khi khởi động.

\section{HTTP Compression}

\subsection{Khái niệm và lợi ích}
HTTP Compression là kỹ thuật nén dữ liệu trước khi gửi từ server đến client, giúp giảm kích thước dữ liệu truyền tải:

\begin{itemize}
    \item \textbf{Giảm băng thông}: Tiết kiệm băng thông và chi phí mạng
    \item \textbf{Tăng tốc độ tải trang}: Người dùng nhận được phản hồi nhanh hơn
    \item \textbf{Cải thiện trải nghiệm}: Đặc biệt hiệu quả với người dùng có kết nối mạng chậm
\end{itemize}

\subsection{Triển khai trong dự án}
Việt Food sử dụng middleware \texttt{compression} của Express để nén dữ liệu:

\begin{verbatim}
Hệ thống sử dụng middleware `compression` của Express với cấu hình tối ưu: ngưỡng nén 1KB để tránh nén dữ liệu nhỏ không cần thiết, và mức nén 6 đảm bảo cân bằng giữa hiệu suất và tỷ lệ nén.
\end{verbatim}

Cấu hình này được thiết lập trong \texttt{server.ts}, áp dụng cho tất cả các request. Điểm đáng chú ý:



\begin{itemize}
    \item \textbf{threshold 1024 bytes}: Chỉ nén các phản hồi có kích thước lớn hơn 1KB, tránh lãng phí tài nguyên CPU cho các phản hồi nhỏ
    \item \textbf{level 6}: Mức nén cân bằng giữa tốc độ và hiệu quả nén
\end{itemize}

\section{Tối ưu hóa hình ảnh với Sharp}

\subsection{Khái niệm và lợi ích}
Sharp là thư viện xử lý hình ảnh cho Node.js, được xây dựng trên libvips - thư viện xử lý hình ảnh hiệu suất cao:

\begin{itemize}
    \item \textbf{Tốc độ xử lý cao}: Nhanh hơn nhiều so với các thư viện xử lý ảnh thông thường
    \item \textbf{Tiết kiệm bộ nhớ}: Sử dụng bộ nhớ hiệu quả khi xử lý ảnh lớn
    \item \textbf{Tối ưu hóa định dạng}: Chuyển đổi sang các định dạng hiệu quả như WebP
    \item \textbf{Thay đổi kích thước}: Giảm kích thước ảnh nhưng vẫn giữ chất lượng tốt
\end{itemize}

\subsection{Triển khai trong dự án}
Việt Food sử dụng Sharp thông qua middleware \texttt{image-processor.middleware.ts} để xử lý ảnh khi người dùng tải lên.

Hệ thống xử lý ảnh tải lên bằng thư viện Sharp, thực hiện các bước tối ưu: chuyển đổi sang định dạng WebP, giảm kích thước tối đa 1000px, đặt chất lượng 80% và mức nén tối ưu. Ảnh gốc được xóa sau khi xử lý để tiết kiệm không gian lưu trữ.

Middleware này thực hiện các tối ưu:

\begin{itemize}
    \item \textbf{Resize}: Giảm kích thước ảnh xuống tối đa 1000px để tiết kiệm không gian lưu trữ
    \item \textbf{Chuyển đổi sang WebP}: Định dạng hiện đại có kích thước nhỏ hơn nhưng chất lượng tương đương hoặc tốt hơn JPEG/PNG
    \item \textbf{Điều chỉnh chất lượng}: Cân bằng giữa kích thước file và chất lượng hình ảnh (quality: 80)
    \item \textbf{Mức độ nén tối ưu}: Cấu hình effort: 6 đảm bảo cân bằng giữa tốc độ xử lý và hiệu quả nén
\end{itemize}

Middleware này được áp dụng cho các route xử lý upload hình ảnh, đảm bảo tất cả hình ảnh đều được tối ưu trước khi lưu trữ.

\section{Hệ thống Agent thông minh}

\subsection{Giới thiệu về Agent}

Việt Food triển khai một hệ thống Agent thông minh hỗ trợ khách hàng trong quá trình đặt món và tương tác với ứng dụng:

\begin{itemize}
    \item \textbf{Trợ lý ảo}: Agent hoạt động như một trợ lý ảo thông minh, tương tác với người dùng qua giao diện chat
    \item \textbf{Xử lý ngôn ngữ tự nhiên}: Sử dụng mô hình NLP để hiểu và phản hồi câu hỏi của người dùng
    \item \textbf{Tư vấn món ăn}: Gợi ý món ăn dựa trên sở thích và lịch sử đặt hàng của người dùng
    \item \textbf{Xử lý quy trình}: Hướng dẫn người dùng hoàn thành quy trình đặt hàng
\end{itemize}


\subsection{Lưu trữ message và quản lý context}

Một trong những thách thức lớn nhất của hệ thống Agent là việc lưu trữ tin nhắn và duy trì context hội thoại. Việt Food sử dụng MongoDB để lưu trữ tin nhắn và Redis để quản lý context session:

Mô hình dữ liệu tin nhắn được thiết kế với các trường chính sau:

\begin{itemize}
    \item `userId`: Định danh duy nhất của người dùng, dùng để liên kết tin nhắn với tài khoản người dùng cụ thể
    \item `content`: Nội dung văn bản của tin nhắn, được mã hóa UTF-8
    \item `role`: Phân biệt giữa tin nhắn từ người dùng (`user`) và hệ thống (`system` hoặc `assistant`)
    \item `timestamps`: Tự động thêm thời gian tạo (`createdAt`) và cập nhật (`updatedAt`)
\end{itemize}

Dịch vụ `MessageService` cung cấp bộ phương thức toàn diện để quản lý vòng đời tin nhắn:

\begin{itemize}
    \item Tạo và lưu trữ tin nhắn mới trong cơ sở dữ liệu MongoDB
    \item Truy vấn lịch sử tin nhắn theo người dùng, với phân trang và sắp xếp thời gian giảm dần
    \item Tích hợp Redis Stream cho xử lý bất đồng bộ, đảm bảo khả năng mở rộng
    \item Quản lý trạng thái tin nhắn thời gian thực thông qua WebSocket
\end{itemize}

\subsection{Quản lý context hội thoại}

Duy trì context hội thoại là yếu tố quan trọng để Agent có thể hiểu được tiến trình đối thoại đang diễn ra. Một phương pháp tối ưu để quản lý context hội thoại được triển khai bằng cách sử dụng Google GenAI kết hợp với cơ chế in-memory cache. Hệ thống quản lý các phiên hội thoại thông qua các thành phần chính sau:

\begin{itemize}
    \item \textbf{AgentSessionEntry}: Lưu trữ thông tin phiên hội thoại, bao gồm đối tượng chat và thời gian truy cập cuối cùng
    \item \textbf{Session Management}: Tự động dọn dẹp các phiên không hoạt động sau 1 giờ
    \item \textbf{In-memory Storage}: Sử dụng Map để lưu trữ các phiên với thời gian thực
    \item \textbf{Automatic Cleanup}: Hệ thống tự động dọn dẹp các phiên không hoạt động mỗi 10 phút
\end{itemize}

Cách tiếp cận này đảm bảo hiệu suất cao trong khi vẫn duy trì được trạng thái hội thoại cần thiết cho trải nghiệm người dùng liền mạch. Các function tool quan trọng được triển khai cho hệ thống bao gồm:

\begin{itemize}
    \item \textbf{searchDishes}: Tìm kiếm món ăn theo các tiêu chí
    \item \textbf{addToCart}: Thêm món ăn vào giỏ hàng
    \item \textbf{removeFromCart}: Xóa món ăn khỏi giỏ hàng
    \item \textbf{getDishesInUserCart}: Lấy danh sách món ăn trong giỏ hàng
    \item \textbf{getAllDishes}: Lấy toàn bộ danh sách món ăn
\end{itemize}

\subsection{Vấn đề đang gặp phải}

Hệ thống Agent đang gặp phải một số vấn đề như:

\begin{itemize}
    \item \textbf{Quản lý context hội thoại}: Chưa áp dụng cơ chế lọc context để lấy thông tin cần thiết của người dùng trong cuộc hội thoại

    \item \textbf{Agent}: Chưa tối ưu khả năng làm công việc phức tạp, chỉ hoạt động tốt với các yêu cầu cơ bản

    \item \textbf{Function Calling}: Chưa triển khai đầy đủ các function tool để Agent có thể thực hiện các tác vụ phức tạp
    \item \textbf{Context hội thoại}: Nguy cơ mất dữ liệu message do redis stream không được lưu trữ lâu dài
    
\end{itemize}





